package classwork.lesson170811;

import java.util.ArrayDeque;
import java.util.Collections;

public class Main {
    public static void main(String[] args) {
        System.out.println("asd");
        System.out.println((int)'c');
        System.out.println((int)'C');


    }
}

//в дз по хэшам можно сделать поле hash в Pair
//hw1: сделать бинарный поиск для AL, LL и TreeSet на 1_000_000 Значений; отсортировать, замерить время поиска элемента и еще там штуки
//hw2: при бинарном поиске по массиву если элемент не найден, пусть возвращает место в массиве, куда его надо было бы вставить (отрицательное)
//hint: когда используем гсч: если давать ему один и тот же seed, то он будет генерировать одинаковые последовательности - чтоб заполнить разные коллекции одинаковыми значениями

/*
в treeSet данные сортируются в возрастающем порядке
в деке поп и пуш в голову идут
в TreeSet и TreeMap можно класть только штуки реализующие <? extends Comparable>
    немного про Comparable (2 чу)
например, для сортировок нам нужна операция сравнения на объектах, для этого есть интерфейс Comparable
компилятор не ругается на попытку отсортировать не-Comparable объекты, но выкинет ClassCastException
если мы в классе имплементим Comparable, параметром должен идти сам наш класс
содержит единственный метод - public int CompareTo(T other);
теперь можно их класть во всякие TreeSet'ы, юзать стандартные сортировки массивов объктов и тд.
    а еще есть Comparator (3 чу)
это интерфейс, предоставляющий 100500 методов, но главные - Compare(T, T) и equals (Object o)
если нет возможности/желания делать класс Comparable - можно сделать Collections.sort(collection, Comparator)
делаем что-нить, реализующее Comparator, переопределяем там Compare(T, T) и объект этой радости передаем в Collections.sort(coll, comp);
если мы хотим сравнивать объекты по разным параметрам - пользуются компаратором (создаем 2 класса, реализующих Comparator)
//стандартный алгоритм сортировки объектов устойчив(stable); quicksort неустойчив
компаратор зачастую делают вложенным публичным классом в классе, объекты которого надо сравнивать
TreeSet располагает объекты в красно-черном дереве
сортировка дает нам: бинарный поиск(кстати, на линкед листе его не стоит делать xD), поиск дубликатов
бинарный поиск по коллекции сработает и на неотсортированной, но результат будет непредсказуем
    сортировки
посмотрели selection в конце урока
*/
