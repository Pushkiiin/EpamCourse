package classwork.lesson170714;

public class Main {
    public static void main(String[] args) {
        System.out.println("asd");
    }
}

//спросить про наследование методов, обрабатывающих private поля
//что такое по сути super
//почитать Бадда про наследование
//no hw


/*
поля почти всегда private/package
глобальные переменные (да и методы) - это не ок в ООП; только общение объектов
инкапсуляция методов: то же самое, что с полями (в т.ч. фишка с protected), только не забываем создать экземпляр для non-static методов
при переопределении метода можно изменить доступ только в сторону расширения
еще инкапсуляция едть у вложенных классов, но это потом
в одном файле может быть несколько классов (не вложенных, но только один public, остальные - default)
    Наследование
пересматривать как щучка
extends Object всегда неявно присутствует
clone() & finalize() are protected in Object
явное (нисходящее) преобразование типов - когда мы руками кастим предка к потомку

    Полморфизм
1) В переменных можно сохранять ссылки на объекты любых классов нужного типа (полиморфность)
2) Можно менять поведение разных наследников при получении одного и того же сообщения

в абстрактном классе могут быть какие угодно методы (either abstract or not), или вообще не быть

методы - тоже объекты
super.method() - в объекте "класс-родитель" найти объект "метод method()" и применить его
никакой аналогии с this - полем, содержащем сслыку на данный объект
super.super.method() - так нельзя; через супер можно обратиться к ближайшей реализации метода
super.m(); - идем вверх по иерархии и выполняем первый встреченный метод m()

    про связывание (линковка, linkage)
статическое - когда компилятор заранее знает, в какую точку передается управление
динамическое - когда определение точки передачи управления определяется в момент исполнения кода; пересмотреть

статики наследуются, но их невозможно переопределить. При создании в наследнике метода с такой же сигнатурой получится хайдинг, а не оверрайд

final
запрещает наследование класса
запрещает переопределение метода в наследниках
запрещает менять переменную
при передаче примитива в ф-цию помогает избежать ошибок

*/