package classwork.lesson170627;

public class Main {
    public static void main(String[] args) {
        System.out.println(Integer.MAX_VALUE);
        long l = 214748364L;
        int i = (int)l;
        System.out.println(i);
        long l2 = 100;
        double d = 10;
        int i2 = (int)l2;   //явно указываем, что это будет число подходящего размера
    }
}

//Spring - про настройку окружения? Почекать springbeginner2016 or sth
//2 и 3 части урока - офигенно про конструкторы; повторить
//hw: int to binarystring, hexstring, octalstring; можно написать один метод, принимающий основание системы счисления как параметр

/*
у него этот урок называется 170625
    про классы
объекты создаются с помощью конструктора и его вызова через new
если в классе нет других конструкторов, компилятором создается конструктор по умолчанию
если нет причин поступить иначе, конструктор лучше делать public, но можно юзать любой модификатор
созданием объекта занимается jvm - выделяет собственно память; ошибочно полагать, что это делает конструктор, он только заполняет её
когда создается объект:
1) Отводится место в памяти под все поля, в т.ч. унаследованные
2) Выполняются блоки инициализации для объекта - они нужны чтобы в случае большого кол-ва конструкторов не повторять много кода
3) Выполняются конструкторы
обычные методы могут называться так же, как и класс; 2 отличия конструктора в том, что у него нет возвращаемого типа и он не наследуется
конструкторы одного класса могут обращаться друг к другу через this
//singleton юзается для создания соединения с бд, например
при создании экземпляра класса происходит еще и инициализация полей
final делает объект immutable - очень полезно для многопоточки
когда мы определяем переменную как final, туда не ставится значение по умолчанию, надо будет инициализировать руками
поля класса получают значения по умолчанию, а локальные переменные (в методах) - нет
иногда может иметь смысл создать объект, не запоминая на него ссылку, только ради выполнения блоков инициализации/конструктора/статиков
примитивы:
byte(8), short(16), int(32), long(64), char(16), float(32), double(64), boolean(1)
переменная ссылочного типа хранит адрес в куче, поэтому её размер зависит от архитектуры (32/64 бита); указыввется в jvm
стек выполнения - область оперативной памяти, где чо-то там
место под локальные переменные отводится в стеке выполнения
когда метод работает, компилятор отводит в нем место под локальные переменные, в т.ч. под адреса объектов
а вот сами объекты хранятся в динамической памяти, а из стека выполнения в них идет указатель
    теперь посмотрим, как объекты взаимодействуют
сборщик мусора (GC) уничтожает объект, если на него нет ссылок из стека выполнения
формально можно восстановить:
hook == callback - спец.код, который будет выполняться при завершении чего-либо, пример такой радости:
finalize - код, который будет выполняться перед сборкой мусора. Если сборщик мусора не запустился, или не дошёл до объекта - он не выполнится
из finalize можно получить адрес данного объекта через this и куда-нить сохранить


    afterwatch
в конструкторе всегда неявно идет первой строкой вызов такого же конструктора у предка
если в предке не определять конструктор без параметров, то в конструкторе наследника придется явно указывать, какой super() вызывать

*/
