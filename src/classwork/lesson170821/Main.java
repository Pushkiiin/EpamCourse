package classwork.lesson170821;

public class Main {
    public static void main(String[] args) {
        System.out.println("asd");
    }
}

//jvisualvm - программа внутри jdk, показывающая, что там внутри происходит - стоит почекать; там все потоки видны даже
//ссылки на методы выглядят как :: - погуглить

/*
    лямбды (пересмотреть 1 и 2 части мастхев)
//closure - замыкания
раньше если мы хотели создать кусок кода, который можно передавать по ссылке, мы юзали анонимный класс
т.о. по сути создается объект с одним нужным методом внутри

2 часть - интересно, но там жесть какая-то
//effectively final - переменная, не определенная как final, но при этом её значение нигде не меняется
лямбда-выражение не является объектом, это просто код, но ссылку на него можно сохранить в переменную

3
лямбда-выражение имеет тип, чтобы можно было сохранить ссылку на него в переменную типа интерфейса
аннотация @FunctionalInterface - специально введена в java 8, чтобы обозначить интерфейсы, пригодный для работы с лямбдами
функциональный - интерфейс с всего одним методом public abstract
Supplier - поставщик (интерфейс) - обращаемтся к нему, получаем объект указанного типа. Всё.
Runnable - ничего не возвращает и не принимает, Supplier - только возвращает, Consumer - только принимает

4 про функицональные дескрипторы - похоже на операторы в формальной логике

5-6 какая-то адовейшая жесть

 */
