package classwork.lesson170802;

import java.util.Vector;

public class Main {
    public static void main(String[] args) {
        System.out.println("dsa");
        String s = "" + 1 + 2;
        System.out.println(String.class.toString());
        System.out.println(s);
    }
}

/*
//в сигнатуре main можно юзать (String... args) и (String args[])
блоки try-catch-finally тоже отделяют свои границы видимости, соотв. объявленные в них перемнные видны только внутри одного блока

    generics (пересмотреть обязательно, протупил все занятие)
параметризованный - с подставленным значением параметра (List<String>); обобщенный тип - без (List)
Collections.checkedList() - лист, проверяющий тип содержимых объектов - в случае чего скомпилится, но выкинет runtime
//в default методах интерфейсов можно обращаться к this, таким образом получая доступ ко всем методам Object'a
//в интерфейсах можно делать static методы
дефолт-методы интерфейсов - тоже пример обобщенного кода - им все равно, с чем работать
обычно обобщенный тип обозначают просто заглавной буквой: E - element; K - key; V - value; T - type...
зам какая-то затыка с массивами и обобщенными типами еще
когда компилятор скомпилирует обобщенный класс, вся инфа о типах исчезает - т.о. Е превратится в Object
глобально есть такая тема: если нужен массив зачастую стоит юзать ArrayList - в т.ч. для параметризованных типов
иногда обобщенный код называют еще одним проявлением полиморфизма
параметризация метода всегда указывается до указания возвращаемого значения: public static <T> void sort(){}; все остальное - это уже его использование
public static <T> void sort(){};    public static <T> int sort(){};     public static <T> T modify(T t){};
при параметризации методов обычно параметр называют M, чтоб не путаться с параметрами класса например, если они есть
нельзя создать статик-переменную типа параметра
*/
