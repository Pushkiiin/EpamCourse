package classwork.lesson170726;

public class Main {
    public static void main(String[] args) {
        System.out.println("asd");
    }
}

//iluwatar - zbs patterns
//занятия будут начинаться теперь в 11-30

/*
статик методы наследуются. Их нельзя переопределить - при создании такого же метода происходит хайдинг.
Но если на потомке ничего не делать со статик методом предка, на его экземпляре его можно будет вызвать и он будет предковский.

abstract class vs interface
общее:
это типы
разница:
ас может иметь реализацию методов
могут быть приватные/протектед методы в ac
i не может содержать состояние (поля)
множественное наследование; наследование и имплементация

еще немного про anon & local
они нужны как правило когда нам внутри какого-то метода надо наштамповать много однотиных объектов, которые не нужны снаружи
анон внутри метода имеет доступ к полям внешнего
паттерн "фабричный метод" - потому что работа с конструкторами напрямую дает ConstructorDependency, но не есть гуд
идея паттерна в том, что мы плодим объекты внутри
если у нас поле final - на нас будет ругаться компилятор, пока мы не присвоим ему значение, т.о. мы не сможем достучаться до дефолтного null внутри него
как парвило мы хотим, чтобы наши объекты гибко меняли поведение по ходу программы.
сначала происходит инициализация полей на месте, потом блоки инициализации, потом конструкторы
до создания объекта будут инициализированы все его final'ы
модификаторы доступа есть только у полей
наследниик должен унаследоваать уже присвоенное значение константы, даже от абстрактного предка потому что: (watch next line)
при вызове конструктора потомка сначала вызывается конструктор предка, потом потомка

    про интерфейсы
в 8 джаве можно сделать default-реализацию методов; а еще статические методы, про которые я нихера не понял
в интерфейсе могут быть статические поля, которые по дефолту становятся final, чоооооооооооооо??? и классы еще - только static inner, при чем это по дефолту приписывается
Iterator - интерфейс, можно подраскурить чутка
list.iterator() - фабричный метод, возвращает объект типа Iterator, но нам не говорит, какого он класса (приватного и не важного)
Iterable - интерфейс, определяющий классы, которые можно перебрать поэлементно

протокол - совокупность всех методов, доступных у объекта (от своего класса, предков и интерфейсов)

 */