package classwork.lesson170818;

public class Main {
    public static void main(String[] args) {
        System.out.println("asd");
        String a = "a";
        String b = "b";
        System.out.println(a.compareTo(b));
    }
}

/*
начало - про priority queue, booooaaaariiing

    bst
симметричный порядок - когда ключ узла больше всех ключей левого поддерева и меньше --''-- правого
нам это дает логарифмический поиск ключа
//слово "ключ" само по себе не означает уникальность, просто для большинства структур их делают уникальными
в бст как правило поиск ведется по ключу, а возвращается значение
inOrder traversal - слева направо (по порядку) - сначала обходим поддерево узла, потом пишем значение;      left-current-right
юзается например чтобы записать эл-ты в список в отсортированном виде, остальные юзаются очень редко
preOrder - как только пришли в узел - сразу записываем его значение                                         current-left-right
postOrder - сначала левое поддерево, потом правое, потом сам узел                                           left-right-current
удаление эл-та из бст - на бумажке хрен напишешь
    2-3-дерево
в узле либо 1 значение - тогда 2 потомка, либо 2 значения - тогда 3 потомка - средний в промежутке между значениями
у седжвика по красоте описано
мы вставляем очередной ключ только в уже существующие узлы и если там становится 3 эл-та, переводим центральный в родителя
    красно-черные бст
по сути это способ релизовать 2-3 дерево с помощью обычного бст
в каждый узел вводится поле, хранящее цвет
по сути это разновидность 2-3-деревьев
left-leaning r-b bst - двойный узлы заменяются на штуку
теоретически при добавлении узла в leaning мы можем получить дерево, не являющеся 2-3 деревом
контрится спецоперациями: поворот налево, поворот направо и смена цветов

бст отличается от хэшмапы: упорядоченный набор данных, ordered operations, не надо вычислять хэши
длинные строки имеет смысл хранить именно в бст

 */