package classwork.lesson170823;

import java.util.stream.Stream;

public class Main {
    public static void main(String[] args) {
        System.out.println("1");
        Stream.generate(Math::random).limit(20).forEach(System.out::println);
    }
}

//стоит посмотреть методы в основных коллекциях, связанные с лямбдами
//hw: есть список, могут быть повторяющиеся, поместить их все в map, ключ - слово, значение - кол-во повторений через лямбды


/*
(1)    Optional
optional - популярная нынче штука, по сути замена для null
идея в том, что оно выкинет ошибку в момент возвращения null, а не в момент обращения к нему, т.е. гораздо более вовремя
еще методы для обработки null (orElse, orElseGet);
крч очень полезная штука в стримах
opt.ifPresent(sout) - правильный вывод
(2)    стримы, чо  (потоки данных; еще есть потоки ввода-вывода и выполнения, но сейчас не о них)
3 части:
1) определяем и описываем источник
2) трасформации - то, что делаем с каждым эл-том; возвращают Stream                                     filter, limit, reduce
3) терминальные операции - операция, которая останавливает стрим, похоже; возвращают non-Stream         count, min, max, findFirst, forEach, anyMatch, collect

синтаксис:
Stream<String> stream = Stream.empty();
можно методом list.stream() скормить коллекцию в стрим
каждая новая трансформация - новый стрим
//wow-момент с прошлого занятия: когда мы передаем куда-то ссылку на метод - она автокастится в функциональный интерфейс
(.3)
один стрим живет до первой терминальной операции
//параметризация работает только для экземпляров, или методов, в статическом контексте не работает
reduce - свертка, представление большого кол-ва данных в виде меньшего кол-ва; например операции count, min
(4)
в многопоточной среде есть смысл юзать праллельные операции (K.O.)
collect - собрать результат в коллекцию (указываем контейнер, как в него добавлять и как объединять контейнеры)
(5) mapping - есть охеренные объяснения, пересмотреть
mapping - ставим каждому эл-ту стрима в соответствие что-то другое
в стриме ничего не выполняется, пока не будет заявлена терминальная операция. А потом смотрится, что делать с каждым элементом
т.о. проход в итоге будет всего один
когда стрим вызывается на др.стриме, они хранят ссылки друг на друга, образуя подобие линкед листа
закрытие одного стрима из списка ведет к закрытию всех стримов в списке

 */