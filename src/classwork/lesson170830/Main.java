package classwork.lesson170830;

public class Main {
    private static class asd implements  Runnable{

        static int counter = 0;
        @Override
        public void run() {
            for (int i = 0; i < 1_000_000; i++) {
                counter++;
            }
        }
    }
    public static void main(String[] args) {
        int x = 3;
        System.out.println(x);
    }
}
//hw - чо-то там с нашей blocking queue

/*
(1)
System.gc(); - запрос на сборку мусора, она не обязательно запустится
native - код внутри самой jvm, как правило платформозависимый
оперативка на несколько порядков медленнее, чем цпу, поэтому в современных архитектурах если работа постоянно идет с какой-то одной переменной,
    то она хранится в кэше/регистре цпу, пока она не понадобится снаружи
//RAM - random access memory
volatile - ядра каждый раз считывают значени переменной из RAM - медленно, но эвойдит проблемы многоядерности
это довольно легковесный способ, но он помогает только если меняется мало переменных
проблема visibility - когда результат действий одного потока не виден другим потокам
преимущество interrupt() заключается в том, что оно сработает даже на спящем потоке
(2) я чет не особо понимаю, что делает его код
Thread.interrupted() - сбрасывает
race condition - вторая потанцевальная проблема, возникает при работе нескольких потоков с одними и теми же данными
это тот самый i++ разными потоками
//атом - греч. неделимый
проблема в том, что считать, изменить значение и записать - не атомарная операция
для атомарности надо выделить участок кода в т.н. критическую секцию
это делается через блок synchronized(mutex){}
mutex - aka monitor - в java им может служить любой объект
если задача описана каким-то Runnable классом, у которого есть только она и нет состояния, то будет достаточно одного объекта этого класса, чтоб кормить эту задачу разным потокам
(3)
объявление synchronized метода - то же самое, что и synchromized(this) - wtf?
sleep вообще говоря тоже не стоит юзать, лучше какой-нить scheduledThreadPool
wait-notify
wait переводит поток в состояние waiting
BLOCKED - когда не можем продолжать работу потому что ждем доступа к монитору
(4)
при переходе в WAITING поток освобождает монитор
worker - kinda design pattern - поток, ждущий появления задачи в очереди задач и выполняющий её при появлении
spurious wake-up - спонтанное пробуждение - когда поток выходит из wait, надо обязательно проверить, не случайно ли это случилось, для этого юзается цикл
считывать и писать надо внутри критической секции - на случай visibility и race conditions
(5)
poison pill - специальный объект, обозначающий конец работы какого-либо механизма, кушающего объекты соотв. типа
 */