package classwork.lesson170828;

public class Main {
    public static void main(String[] args) {
        System.out.println("asd");
        Thread t = new Thread();
        t.start();
        t.isAlive();
    }
}

//java concurrency in practice - книжка по многопоточке написана всякими там жескими разрабами джавы - самый мастхев из этого, остальное - для деталей
//the art of multiprocessor programming - более основательная и теоретическая
//основы многопоточного, параллельногоо и распределенного программирования - это уже не по джаве
//Doug Lee - Concurrent programming in java - про то, как конкарренси создавалась в java; ну дунно

/*
    conc (пересматривать вообще все по жести)
jvm - имитация компа, а комп может параллельно выполняять несколько задач
внутри jvm аналог процессов - потоки;
jvisualvm - позволяет подключиться к выбранной jvm и посмотреть, что там происходит
main - главный поток
park - состояние потока, ожидание задачи
Thread.sleep(int millis) - сделать текущий поток спать
Thread thread = new Thread(); // по сути объект, являющийся представителем (proxy) потока
thread.start(); - запуск
можно передать на вход конструктору Runnable (void -> void)
еще есть Callable<T> с методом call; void -> T
дескриптор такой же, как у Supplier'a

2 способа создать поток:
передать в new Thread(() -> {sout("asd");}).start();    - передача Runnable в конструктор, лучше юзать его
new Thread(){override run{};}.start();                  - анонимный класс (наследование)

но по-хорошему используются executor-services
executors - это специальные объекты, которые помогают с менеджментом потоков
interface executor, у которого есть несколько классов
interface ExecutorService - его наследник с существенно расширенным функционалом
Executors - глобальный класс, типа как Arrays или Collections; в нем есть всякие пулы потоков
Executors.newSingleThreadExecutor - 1 поток, обрабатывающий очереь задач
Executors.newFixedThreadPool(int n) - создает n потоков, которые тягают задачи из очереди
Executors.newCachedThreadPool - создает поток под каждую задачу
Executors.newSchaduledThreadPool() - откладывать задачи относительно времени, начала/конца предыдущего потока и тд  //используются только для планирования, а не для самих задач


    про потоки, ядра и цпу(3)
потоки из jvm мапятся в нити винды
каждое ядро - отдельный вычислительный элемент
распределением задач занимается планировщик задач (как винды, так и jvm)

у потоков есть состояния, можно посмотреть в Thread.State
1)new           - создали, но не запустили
2)runnable      - сейчас что-то выполняет, или готов выполнять. Считает он в данный момент, или нет - решает планировщик задач
3)blocked       -
4)waiting
5)timed_waiting
6)terminated    - когда прекратил свою работу, но ссылка на него (объект Thread) до сих пор есть

поток завершает свою работу, когда завершается метод run() - потом он переходит в состояние terminated
метод t.join(); - делает текущий поток ждать поток t
Thread.currentThread() - статический метод, возвращает ссылку на текущий поток
//частые вопросы на интервью - получить ссылку на текущий поток и на поток-основатель
можно обращаться к потокам из одной группы
любой поток может достучаться до мэйна, если он еще существует

jvm работает до тех пор, пока живет хоть один non-daemon thread
демон убивается прямо посреди выполнения - потенциальная опасность


    про ядро
система разделения времени - это из курса по осям
есть несколько процессов и одно ядро
выделяется какое-то время на 1 цикл и каждый получает равное кол-во времени в этом цикле
но у задач еще есть разные приоритеты и всякое такое, но это уже нюансы
если кол-во runnable потоков меньше кол-ва процессоров, то каждый может занимать по целому циклу на ядре

*/


//потоки vs процессы
//