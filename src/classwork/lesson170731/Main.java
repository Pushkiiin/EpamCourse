package classwork.lesson170731;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Main {
    public static void main(String[] args) {
        System.out.println("asd");
        int ф = 3;
//        System.out.println(3/0);
    }
}
//OCA/OCP Java SE 8 programmer practice tests
//переменные, методы классы и вообще штуки можно называть по-русски)
//в 11:20 собираемся теперь)


/*  хороший урок, пересмотреть
т.к. exception - это класс, мы можем при ошибке туда записать кучу инфы о контексте искл. ситуации
можно после одного блока try ловить несколько разных исключений - они всегда ловятся по порядку, поэтому вначале должны идти наиболее спеифичные
если метод выбрасывает общщий exception - надо отлавливать всех его возможных потомков, иначе не скомпилится
как правило наследовать стоит Exception или RuntimeException, ну или их потомков
если надо перехватить несколько разных ошибок - лучше всего явно отлавливать каждую своим catch'ем (multicatch)
в последних java есть multicatch: catch (IllArgExc | ArithExc | NPE e){} - но они должны быть одноранговые, иначе не скомпилится
throw new WhateverException - немедленно возвращяет из метода
декларация throws нужна только для checked-exceptions и такие методы надо перехватывать

rethrow - повторное выбрасывание - если мы не хотим наверх передавать эксепшен, который мы поймали
таким образом можно заворачивать checked в unchecked и наоборот и это довольно часто юзается

блок finally - как правило для освобождения ресурсов (например захваченный монитор); неосвобожденные ресурсы - очень частый источник утечек памяти
!!если в try и/или catch есть return, то сначала вычисляется его значение, потом срабатывает finally, и только теперь происходит возврат значения
если в catch вылезает еще одно исключение, то все равно сначала выполнится finally, а потом он выбросится
предпоследняя часть урока - про работу с файлами немного и try-with-resource, полезненько
общий good practice - не писать для одного блока try-catch-finally, т.к. finally сам может выкинуть исключение
как правило finally заворачивают во внутренний try-finally, а снаружи обрабатывают try-catch
последняя часть - про сигнатуры методов и throws
если мы переопределяем метод с throws, то мы можем только дать ему throws того же типа (класс + потомки), либо не делать throws
метод без throws нельзя переопределить в потомке, приделав к нему throws
сигнатура метода - имя, тип, передаваемые параметры и всё
 */
