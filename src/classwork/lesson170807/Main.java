package classwork.lesson170807;

import java.util.ArrayList;

public class Main {
    static public void main(String[] args) {
        System.out.println("asd");
        Throwable asd = new Throwable();
        String str = "asddasasd";
        StringBuilder sb = new StringBuilder(str);
    }
}

//курс седжвика по алгоритмам есть на курсере - у него крч охеренно про хэштаблицы

/*
//try сам по себе не может существовать, ему нужен либо catch Либо finally
//по умолчаинию java.lang всегда импортирован, а throwable лежит в нем
метод может сообщать throws, но при этом не выбрасывать исключения, но перехватывать его все равно надо будет(если оно checked)
если оно m() throws RuntimeException{} - его перехватывать не надо
    some more collections
set - мн-во неплвторяющихся объектов - интерфейс
HashSet, LinkedHashSet, TreeSet - абсолютно то же, что и с мапами
внутри HashSet - это HashMap, где в качестве ключа наш объект, а значение - заглушка new Object(); в некоторых реализациях и K и V - исходный объект
2 часть урока - про основные методы основных коллекций, можно пересмотреть, там есть новые штуки
    arraylist vs linkedlist
AL заполняется быстрее - по сути это много добавлений в конец
добавление эл-та в начало лучше у LL
то же самое с удалением с начала и конца
для удаления из середины LL надо туда еще дойти - так что в обоих случаях это такая себе операция - не понятно, что лучше
//миграция структур - перегон данных из одной структуры в другую, чтоб воспользоваться её плюсами
    про хэш-таблицы (4 чсть урока - есть норм штуки, советы про определение hashCode(); последняя часть - про совсем подробности hashTable)
хэш - это числовое значение, однозначно определяемое конкретным объектом
Object.hashCode() - ф-ция от положения объекта в памяти
если мы хотим, чтоб равные по equals объекты считались равными, надо переопределить hashCode
у Integer'a хэшкод - само это число
//вообще у разных базовых классов стоит посмотреть реализации hashCode()
если класс immutable, имеет смысл в каждом объекте держать переменную под хэшкод, чтоб вычислять его всего один раз для объекта
это называется кэшированием хэшкода;  так же имеет смысл, если объект очень редко меняет состояние
вычисление хэшкода - самая дорогая операция при работе с хэштаблицами

 */