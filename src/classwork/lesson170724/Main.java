package classwork.lesson170724;

import java.awt.event.MouseEvent;

public class Main {
    public static void main(String[] args) {
        System.out.println("asd");

    }
}

//swing - про оконные приложения?
//java SE specification - все технические подробности, лютая жесть
//hw - аналог дога, побольше раздражителей (почесать, помыть) для крысы, кошки; для кошки с внутренними классами, а для крысы/хомячк со внешними
//на уроке у нас brain имплементил pet, для интерфейсов это вполне нормально, для классов было бы ошибкой


/*
//в начале урока подробный план занятий; а потом чет сложна пошло, пересмотреть
можно скастить руками наследника к предку, а наоборот компилятор не пропустит
абстрактный класс может не реализовывать методы из реализуемого интефейса
serializable - интерфейс-метка, т.е. в нем нет методов
Он говорит, что содержимое объекта можно упаковать в массив byte и передать; все примитивы по определению сериализуемы
в этом массиве зашифрованы все поля объекта, их типы
если объект Serializable - значит все его поля serializable
создавать копию объекта можно через Cloneable, но так же и через serializable
serializable & externalizable
instanceof работает на интерфейсах

    вложенные классы    (3 часть урока пересмотреть, там есть очень крутые штуки)
есть разные нотации, но всем как обычно; мы будем юзать такие:
nested: Static, Inner, Local, Anonymous
вложенным классам можно указывать любой модификатор доступа (в отиличие от public/package внешних классов)
//все вопросы сводятся обычно к тому, как создавать экземпляр класса

static - просто обычный класс внутри класса. Ничем от внешних не отличаются, в т.ч. не могут иметь прямого доступа к полям и методам внешнего класса
крч это просто обособленный класс, просто физически расположенный внутри другого. Но он имеет доступ к static-полям, что не рекомендуется делать
обращение через имя внешнего класса и через точку

inner - класс внутри экземпляра. В нем помимо this есть ссылка на текущий объект внешнего класса
создать экземпляр внутреннего можно только имея экземпляр внешнего
у каждого внутреннего экземпляра будет неявная ссылка на породивший его внешний объект, поэтому он может напрямую обращаться к его методам и полям
//автомат - предпринимает различные действия в зависимости от состояния
//refactor - extract interface - может быть юзфул
интерфесы расширяют интерфейсы, а не реализуют

anonymous - по сути юзается для передачи ссылок на методы; просто синтаксический сахар
анонимные классы можно делать от интерфейса (new InterfaceName(){code})
//функциональный интерфейс - интерфейс с одним методом

local - чуть более расширенная запись анонимного
отличие локальных от анонимных в том, что чтобы сделать еще одну операцию, в случае анонимного класса будет создаваться новый класс; яннп крч
локальный нужен чтобы наштамповать много объектов внутри одного метода
идея фабричного метода - в том, чтобы внутри него заделать локальный класси возвращать набор его экземпляров
таким образом никто снаружи не сможет создавать эти объекты - инкапсуляция

 */
